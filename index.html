<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Slope Field</title>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">
  <style>
    :root{
      --bg:#0e1424; --panel:#111827; --ink:#e5e7eb; --muted:#9aa6b2;
      --grid:#1f2a3a; --axis:#e5e7eb; --field:#9fb3c8;
      --c1:#60a5fa; --c2:#34d399; --c3:#f87171;
      --handle-outline:#0e1424;
      --control-bg:#0f172a; --control-border:#233044; --control-hover:#1b2638;
      --accent:#f59e0b; /* orange */
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans";
         color:var(--ink);background:var(--bg)}
    .wrap{max-width:1160px;margin:24px auto;padding:0 16px}
    h1{font-size:24px;margin:0 0 8px}
    .muted{color:var(--muted);font-size:14px}
    .bar{display:flex;flex-wrap:wrap;gap:16px;align-items:center;margin:16px 0}
    .panel{background:var(--panel);border:1px solid var(--control-border);border-radius:16px;
           box-shadow:0 1px 2px rgba(0,0,0,.35);overflow:hidden}
    .legend{display:flex;gap:16px;font-size:14px;align-items:center;color:var(--muted)}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block}
    .select{padding:6px 10px;border:1px solid var(--control-border);border-radius:10px;
            background:var(--control-bg);color:var(--ink);font-size:14px}
    .btn{background:var(--control-bg);color:var(--ink);border:1px solid var(--control-border);
         padding:6px 10px;border-radius:10px;cursor:pointer}
    .btn:hover{background:var(--control-hover)}
    .status{font-size:12px;color:var(--muted);margin-top:4px}
    .status.error{color:#fca5a5}
    canvas{display:block;width:100%;height:auto;touch-action:none}

    /* equation input box */
    .eqn{
      display:flex;align-items:center;gap:8px;background:var(--control-bg);color:var(--ink);
      border:1px solid var(--accent); border-radius:10px; padding:8px 12px; min-width:320px;
      box-shadow: 0 0 0 2px rgba(245,158,11,.18);
    }
    .plain{min-width:260px;border:none;outline:none;font-size:16px;background:transparent;color:var(--ink)}
    .mq-editable-field,.mq-math-mode{min-height:32px}

    /* click-to-set selector */
    .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--control-border);
      border-radius:10px;background:var(--control-bg);cursor:pointer}
    .chip input{margin:0}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Slope Field</h1>
    <div class="muted">
      Domain: x ∈ [-5, 5], y ∈ [-2π, 2π]. Drag the colored points (now anywhere) or click the canvas to set a start point (x₀,y₀) for the selected color.
      Type an explicit ODE f(x,y) or an implicit ODE using y'/dy/dx and '=' (e.g. <code>y' + tan(x)*y = x*sin(2*x)</code>).
    </div>

    <div class="bar">
      <div class="eqn">
        <span id="mq" style="display:none"></span>
        <input id="plain" class="plain" placeholder="y' + tan(x)*y = x*sin(2*x)" />
      </div>

      <div>
        <label for="arrowMode" style="color:var(--muted);font-size:14px;margin-right:6px;">Arrowheads</label>
        <select id="arrowMode" class="select">
          <option value="forward" selected>Forward (+x)</option>
          <option value="backward">Backward (−x)</option>
          <option value="both">Both ends</option>
          <option value="none">None</option>
        </select>
      </div>

      <div class="legend" id="legend">
        <span><span class="dot" style="background:var(--c1)"></span>
          start (x₀,y₀) = <span id="p1">(0.000, 1.000)</span></span>
        <span><span class="dot" style="background:var(--c2)"></span>
          start (x₀,y₀) = <span id="p2">(0.000, 2.000)</span></span>
        <span><span class="dot" style="background:var(--c3)"></span>
          start (x₀,y₀) = <span id="p3">(0.000, -1.000)</span></span>
      </div>

      <label class="chip"><input type="radio" name="which" value="0" checked>
        <span class="dot" style="background:var(--c1)"></span> click → Blue</label>
      <label class="chip"><input type="radio" name="which" value="1">
        <span class="dot" style="background:var(--c2)"></span> click → Green</label>
      <label class="chip"><input type="radio" name="which" value="2">
        <span class="dot" style="background:var(--c3)"></span> click → Red</label>

      <label class="chip"><input id="showSol" type="checkbox" checked> Show solutions</label>
    </div>

    <div class="status" id="status">Parsed as: <code id="parsed">y' + tan(x)*y = x*sin(2*x)</code></div>

    <div class="panel">
      <canvas id="canvas" width="980" height="640"></canvas>
    </div>

    <div class="bar" style="gap:8px;margin-top:10px;">
      <button class="btn" id="resetPoints">Reset initial points</button>
      <button class="btn" id="resetEqn">Reset equation</button>
      <span class="status" id="note" aria-live="polite"></span>
    </div>

    <div class="muted" style="font-size:12px;margin-top:8px">
      Tip: Use LaTeX (<code>\\sin(y)</code>, <code>\\cos(x+y)</code>, <code>\\sqrt{1+y^2}</code>, <code>\\frac{y}{1+x^2}</code>) or plain text (<code>sin(y)</code>).
      Functions: sin, cos, tan, exp, log (ln), sqrt, +, −, *, /, ^. Variables: x, y, and (implicitly) y'.
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js" defer></script>
  <script>
  (function(){
    const xmin=-5, xmax=5, ymin=-2*Math.PI, ymax=2*Math.PI;
    const width=980, height=640;

    // --- state ---
    let x0s=[0,0,0], y0s=[1,2,-1];
    let which=0;                // which curve to set by click
   // let step=0.02;              // fixed internal step
    let step=0.002;              // fixed internal step
    let arrowMode='forward';
    let nx=21, ny=25, L=16;
    let showSol=true;

    let latex = "y' + tan(x)*y = x*sin(2*x)";
    let usingPlain = true;
    let parseError = "";
    let modeInfo = "implicit F(x,y,y')=0";
    let compiledF = (x,y)=>Math.sin(y); // stub until build

    // --- DOM ---
    const canvas=document.getElementById('canvas');
    const ctx=canvas.getContext('2d');
    const arrowSel=document.getElementById('arrowMode');
    const showSolInput=document.getElementById('showSol');
    const resetPoints=document.getElementById('resetPoints');
    const resetEqn=document.getElementById('resetEqn');
    const parsedEl=document.getElementById('parsed');
    const statusEl=document.getElementById('status');
    const p1=document.getElementById('p1'), p2=document.getElementById('p2'), p3=document.getElementById('p3');
    const note=document.getElementById('note');
    const mqSpan=document.getElementById('mq');
    const plain=document.getElementById('plain');

    // hidpi
    function setupHiDPI(){
      const dpr=window.devicePixelRatio||1;
      canvas.style.width=width+'px'; canvas.style.height=height+'px';
      canvas.width=width*dpr; canvas.height=height*dpr;
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    setupHiDPI(); window.addEventListener('resize',()=>{setupHiDPI(); render();});

    // coords
    const xToPx=x=>(x-xmin)/(xmax-xmin)*width;
    const yToPx=y=>height-(y-ymin)/(ymax-ymin)*height;
    const pxToX=px=>xmin+(px/width)*(xmax-xmin);
    const pxToY=py=>ymin+(1-py/height)*(ymax-ymin);

    // parse helpers (LaTeX -> expr string)
    function latexToExpr(lx){
      try{
        let s=(lx||"").trim(); if(!s) return "";
        s=s.replace(/\\left|\\right/g,"")
           .replace(/\\cdot|\\times/g,"*")
           .replace(/\\pi/g,"pi")
           .replace(/\\sin/g,"sin").replace(/\\cos/g,"cos").replace(/\\tan/g,"tan")
           .replace(/\\exp/g,"exp").replace(/\\ln/g,"log")
           .replace(/\\sqrt\\s*\\{([^{}]+)\\}/g,"sqrt($1)")
           .replace(/\\frac\\s*\\{([^{}]+)\\}\\s*\\{([^{}]+)\\}/g,"($1)/($2)")
           .replace(/\\{/g,"(").replace(/\\}/g,")")
           .replace(/\\s+|\\,/g,"");
        // accept y(x), y(), x()
        s=s.replace(/\by\s*\(\s*x\s*\)/gi,'y').replace(/\by\s*\(\s*\)/gi,'y').replace(/\bx\s*\(\s*\)/gi,'x');
        return s;
      }catch(e){return "";}
    }
    const isImplicitString = s => /=/.test(s)||/y'/.test(s)||/dy\/dx/.test(s);

    // compilers
    function compileExplicit(expr){
      const js=String(expr).replace(/\^/g,'**');
      const raw=new Function('x','y','sin','cos','tan','exp','log','sqrt','pi','e',
        `"use strict"; const v=(${js}); return Number.isFinite(v)?v:NaN;`);
      const f=(x,y)=>raw(x,y,Math.sin,Math.cos,Math.tan,Math.exp,Math.log,Math.sqrt,Math.PI,Math.E);
      void f(0,0); return f;
    }
    function compileImplicit(exprRaw){
      let s=String(exprRaw).replace(/\s+/g,'');
      s=s.replace(/\by\s*\(\s*x\s*\)/gi,'y').replace(/\by\s*\(\s*\)/gi,'y').replace(/\bx\s*\(\s*\)/gi,'x');
      s=s.replace(/dy\/dx/g,'m').replace(/y'/g,'m');
      if(s.includes('=')){ const parts=s.split('='); s=`(${parts[0]})-(${parts.slice(1).join('=')})`; }
      s=s.replace(/\^/g,'**');
      const rawF=new Function('x','y','m','sin','cos','tan','exp','log','sqrt','pi','e',
        `"use strict"; const v=(${s}); return Number.isFinite(v)?v:NaN;`);
      const F=(x,y,m)=>rawF(x,y,m,Math.sin,Math.cos,Math.tan,Math.exp,Math.log,Math.sqrt,Math.PI,Math.E);

      const EPS=1e-6;
      function slope(x,y){
        const F0=F(x,y,0); if(!Number.isFinite(F0)) return NaN;
        const d0=(F(x,y,EPS)-F(x,y,-EPS))/(2*EPS);
        let m=(Number.isFinite(d0)&&Math.abs(d0)>1e-12)?-F0/d0:0;
        for(let it=0; it<12; it++){
          const f=F(x,y,m); if(!Number.isFinite(f)) return NaN;
          if(Math.abs(f)<1e-10) break;
          const df=(F(x,y,m+EPS)-F(x,y,m-EPS))/(2*EPS);
          if(!Number.isFinite(df)||Math.abs(df)<1e-12) return NaN;
          m-=f/df; if(!Number.isFinite(m)) return NaN;
        }
        return m;
      }
      void slope(0,0);
      return slope;
    }
    function rebuildFunction(){
      const exprRaw=latexToExpr(latex)||latex;
      try{
        if(!isImplicitString(exprRaw)){
          compiledF=compileExplicit(exprRaw); modeInfo="explicit f(x,y)"; parseError="";
        }else{
          compiledF=compileImplicit(exprRaw); modeInfo="implicit F(x,y,y')=0"; parseError="";
        }
        statusEl.className='status';
        parsedEl.textContent=exprRaw;
      }catch(e){
        parseError=e&&e.message?e.message:'Could not parse expression.';
        statusEl.className='status error'; parsedEl.textContent=parseError;
        compiledF=()=>NaN;
      }
    }

    // RK4 single step (basic)
function rk4Step(f, x, y, h){
  const k1 = f(x, y);
  const k2 = f(x + h/2, y + (h/2)*k1);
  const k3 = f(x + h/2, y + (h/2)*k2);
  const k4 = f(x + h, y + h*k3);
  return y + (h/6)*(k1 + 2*k2 + 2*k3 + k4);
}

function integrateBoth(f, x0, y0, xMin, xMax, hInit){
  const tol = 1e-5;       // סף דיוק
  const hMin = 1e-5;      // צעד מינימלי
  const hMax = 0.05;      // צעד מקסימלי

  function integrateDir(sign){
    let x = x0, y = y0;
    let h = hInit;            // צעד תמיד חיובי
    const xs = [x], ys = [y];

    for(let i=0; i<100000; i++){
      if((sign>0 && x>=xMax) || (sign<0 && x<=xMin)) break;
      if(!Number.isFinite(y)) break;

      // לא לעבור את הגבולות
      if(sign>0 && x+h > xMax) h = xMax - x;
      if(sign<0 && x-h < xMin) h = x - xMin;

      // חישוב צעד מלא + שני חצאים
      const yFull  = rk4Step(f, x, y,  sign*h);
      const yHalf1 = rk4Step(f, x, y,  sign*h/2);
      const yHalf2 = rk4Step(f, x + sign*h/2, yHalf1, sign*h/2);

      // שגיאה יחסית
      const scale = Math.max(1, Math.abs(yHalf2));
      const err = Math.abs(yHalf2 - yFull) / scale;

      // אם הצעד סביר – מקבלים אותו
      if(err < tol || h <= hMin*1.1){
        x += sign*h; 
        y = yHalf2;
        xs.push(x); ys.push(y);
      }

      // התאמת הצעד
      if(err > tol){
        const s = 0.9 * Math.pow(tol/err, 0.25);
        h = Math.min(hMax, Math.max(hMin, s*h));
      } else {
        h = Math.min(hMax, 2*h);
      }
    }
    return {xs, ys};
  }

  const forward  = integrateDir(+1);
  const backward = integrateDir(-1);

  backward.xs.reverse(); backward.ys.reverse();
  return { xs: backward.xs.concat(forward.xs),
           ys: backward.ys.concat(forward.ys) };
}

    // find finite start near given (x0,y0)
    function findFiniteStart(x0,y0,f){
      const tries=[0,1e-4,-1e-4,5e-4,-5e-4,1e-3,-1e-3,5e-3,-5e-3,1e-2,-1e-2,5e-2,-5e-2,0.1,-0.1];
      for(const dx of tries){
        const m=f(x0+dx,y0);
        if(Number.isFinite(m)) return x0+dx;
      }
      return null;
    }

    // drawing
    function drawGrid(){
      ctx.clearRect(0,0,width,height);
      ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--panel').trim()||'#111827';
      ctx.fillRect(0,0,width,height);
      ctx.lineWidth=1;
      ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid').trim()||'#1f2a3a';
      ctx.beginPath();
      for(let gx=Math.ceil(xmin); gx<=Math.floor(xmax); gx++){ const px=xToPx(gx); ctx.moveTo(px,0); ctx.lineTo(px,height); }
      for(let gy=-6; gy<=6; gy++){ const py=yToPx(gy); ctx.moveTo(0,py); ctx.lineTo(width,py); }
      ctx.stroke();
      ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--axis').trim()||'#e5e7eb';
      ctx.lineWidth=1.5;
      ctx.beginPath();
      ctx.moveTo(xToPx(0),0); ctx.lineTo(xToPx(0),height);
      ctx.moveTo(0,yToPx(0)); ctx.lineTo(width,yToPx(0));
      ctx.stroke();

      ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--ink').trim()||'#e5e7eb';
      ctx.font='14px ui-sans-serif, system-ui, -apple-system';
      ctx.textAlign='center';
      for(let gx=Math.ceil(xmin); gx<=Math.floor(xmax); gx++){ ctx.fillText(String(gx), xToPx(gx), yToPx(0)+16); }
      ctx.textAlign='right'; ctx.textBaseline='middle';
      for(let gy=-6; gy<=6; gy++){ if(Math.abs(gy)===6) continue; ctx.fillText(String(gy), xToPx(0)-6, yToPx(gy)); }
    }
    function drawArrow(x0,y0,x1,y1,color,headLen=6,headAng=0.5,mode='forward'){
      ctx.strokeStyle=color; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
      if(mode==='none') return;
      const dx=x1-x0, dy=y1-y0, ang=Math.atan2(dy,dx);
      const drawHeadAt=(x,y,a)=>{ const a1=a-headAng,a2=a+headAng;
        const xh1=x-headLen*Math.cos(a1), yh1=y-headLen*Math.sin(a1);
        const xh2=x-headLen*Math.cos(a2), yh2=y-headLen*Math.sin(a2);
        ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(xh1,yh1);
        ctx.moveTo(x,y); ctx.lineTo(xh2,yh2); ctx.stroke();
      };
      if(mode==='forward'||mode==='both') drawHeadAt(x1,y1,ang);
      if(mode==='backward'||mode==='both') drawHeadAt(x0,y0,ang+Math.PI);
    }
    function drawSlopeField(){
      const col=getComputedStyle(document.documentElement).getPropertyValue('--field').trim()||'#9fb3c8';
      const stepx=(xmax-xmin)/(nx-1), stepy=(ymax-ymin)/(ny-1), mCap=1e3;
      for(let i=0;i<nx;i++) for(let j=0;j<ny;j++){
        const x=xmin+i*stepx, y=ymin+j*stepy, m=compiledF(x,y);
        if(!Number.isFinite(m)) continue;
        const cx=xToPx(x), cy=yToPx(y);
        if(Math.abs(m)>mCap){ const half=L/2; drawArrow(cx,cy-half,cx,cy+half,col,5,0.5,arrowMode); continue; }
        const vx=xToPx(x+1)-xToPx(x), vy=yToPx(y+m)-yToPx(y), len=Math.hypot(vx,vy); if(!len) continue;
        const ux=(vx/len)*(L/2), uy=(vy/len)*(L/2);
        drawArrow(cx-ux,cy-uy,cx+ux,cy+uy,col,5,0.5,arrowMode);
      }
    }
    function drawSolution(x0,y0,color){
      const start= findFiniteStart(x0,y0,compiledF);
      if(start===null) return;
      const {xs,ys}=integrateBoth(compiledF,start,y0,xmin,xmax,step);
      ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath();
      for(let k=0;k<xs.length;k++){ const px=xToPx(xs[k]), py=yToPx(ys[k]); (k===0)?ctx.moveTo(px,py):ctx.lineTo(px,py); }
      ctx.stroke();
    }
    function drawHandle(x0,y0,color){
      const r=6, px=xToPx(x0), py=yToPx(y0);
      ctx.fillStyle=color; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--handle-outline').trim()||'#0e1424';
      ctx.lineWidth=1.5; ctx.stroke();
    }

    // render
    function render(){
      p1.textContent=`(${x0s[0].toFixed(3)}, ${y0s[0].toFixed(3)})`;
      p2.textContent=`(${x0s[1].toFixed(3)}, ${y0s[1].toFixed(3)})`;
      p3.textContent=`(${x0s[2].toFixed(3)}, ${y0s[2].toFixed(3)})`;
      if(parseError){ statusEl.className='status error'; parsedEl.textContent=parseError; }
      else{ statusEl.className='status'; parsedEl.textContent=(latexToExpr(latex)||latex)+' ['+modeInfo+']'; }

      drawGrid();
      drawSlopeField();
      if(showSol){
        const c1=getComputedStyle(document.documentElement).getPropertyValue('--c1').trim()||'#60a5fa';
        const c2=getComputedStyle(document.documentElement).getPropertyValue('--c2').trim()||'#34d399';
        const c3=getComputedStyle(document.documentElement).getPropertyValue('--c3').trim()||'#f87171';
        drawSolution(x0s[0],y0s[0],c1); drawSolution(x0s[1],y0s[1],c2); drawSolution(x0s[2],y0s[2],c3);
        drawHandle(x0s[0],y0s[0],c1); drawHandle(x0s[1],y0s[1],c2); drawHandle(x0s[2],y0s[2],c3);
      }
    }

    // interactions
    let dragIdx=-1;
    canvas.addEventListener('pointerdown',e=>{
      const rect=canvas.getBoundingClientRect(), px=e.clientX-rect.left, py=e.clientY-rect.top;
      const rPick=12;
      dragIdx=-1;
      [[x0s[0],y0s[0]],[x0s[1],y0s[1]],[x0s[2],y0s[2]]].forEach((p,idx)=>{
        if(Math.hypot(px-xToPx(p[0]), py-yToPx(p[1]))<=rPick) dragIdx=idx;
      });
    });
    window.addEventListener('pointermove',e=>{
      if(dragIdx<0) return;
      const rect=canvas.getBoundingClientRect(), px=e.clientX-rect.left, py=e.clientY-rect.top;
      let nx0=pxToX(px), ny0=pxToY(py);
      nx0=Math.max(xmin,Math.min(xmax,nx0));
      ny0=Math.max(ymin,Math.min(ymax,ny0));
      x0s[dragIdx]=nx0; y0s[dragIdx]=ny0; render();
    });
    window.addEventListener('pointerup',()=>{ dragIdx=-1; });

    // click to set selected color if not dragging
    canvas.addEventListener('click',e=>{
      if(dragIdx!==-1) return;
      const rect=canvas.getBoundingClientRect(), px=e.clientX-rect.left, py=e.clientY-rect.top;
      let nx0=pxToX(px), ny0=pxToY(py);
      nx0=Math.max(xmin,Math.min(xmax,nx0));
      ny0=Math.max(ymin,Math.min(ymax,ny0));
      x0s[which]=nx0; y0s[which]=ny0; render();
    });

    // UI bindings
    document.querySelectorAll('input[name="which"]').forEach(r=>{
      r.addEventListener('change',()=>{ which=+r.value; });
    });
    arrowSel.addEventListener('change',()=>{ arrowMode=arrowSel.value; render(); });
    showSolInput.addEventListener('change',()=>{ showSol=showSolInput.checked; render(); });
    resetPoints.addEventListener('click',()=>{ x0s=[0,0,0]; y0s=[1,2,-1]; render(); });
    resetEqn.addEventListener('click',()=>{
      latex="y' + tan(x)*y = x*sin(2*x)";
      if(!usingPlain && window.MathQuill && mqField) mqField.latex(latex);
      if(usingPlain) plain.value=latex;
      rebuildFunction(); render();
    });

    // editor init
    let mqField=null;
    function initEditor(){
      // default text value
      plain.value = "y' + tan(x)*y = x*sin(2*x)";
      if(window.MathQuill){
        try{
          const MQ=window.MathQuill.getInterface(2);
          mqField=MQ.MathField(mqSpan,{spaceBehavesLikeTab:true,
            handlers:{edit:()=>{ latex=mqField.latex(); rebuildFunction(); render(); }}});
          mqField.latex(latex); usingPlain=false; plain.style.display='none'; note.textContent='';
          rebuildFunction(); render(); return;
        }catch(err){}
      }
      usingPlain=true; mqSpan.style.display='none'; plain.style.display='inline-block';
      plain.addEventListener('input',()=>{ latex=plain.value; rebuildFunction(); render(); });
      note.textContent='MathQuill unavailable — using plain text input (e.g. sin(y), cos(x+y), sqrt(1+y^2)).';
      rebuildFunction(); render();
    }
    if(document.readyState==='complete') initEditor(); else window.addEventListener('load',initEditor);
  })();
  </script>
</body>
</html>
